# ====== .zshenv ======
# ENVIRONMENT VARIABLES
# for example $PATH
# should be set in this file..
#
# sourced on all invocations of the shell, unless the -f option is set.
# should contain commands to set the command search path plus other important environment variables.
# should not contain commands that produce output or assume the shell is attached to a tty.
 
# to print each PATH section on its own line: tr ':' '\n' <<< "$PATH" or `echo $PATH | tr ':' '\n'`
# The tr(anslate) utility copies the standard input to the standard output with substitution or deletion of selected characters

# Unison
# uni automates one-way unison syncing from my local laptop onto a remove dev machine. it requires that the project be a git repository 
# so that it can find the project root (when the .git dir is) and that a file `.remoteprojectroot` exists in the project's root directory.
# `.remoteprojectroot` should contain the location of the projects root directory on the remote machine. The intention is that this helper
# function makes it impossible to put the files in the wrong place, or clobber the wrong project.
uni() {
  localProjectRoot=$(git rev-parse --show-toplevel)
  remoteProjectRoot=$(cat $localProjectRoot/.remoteprojectroot)
  host=ext_jmatthews4_wayfair_com
  user=ainb-jmatthews4
  echo "Local Project Root: "$localProjectRoot
  echo "Remote Project Root: "$remoteProjectRoot
  # Including the preference `-force root` causes Unison to resolve all differences (even non-conflicting changes) in favor of root.
  # This effectively changes Unison from a synchronizer into a mirroring utility. 
  unison -batch -color true $localProjectRoot ssh://$host@$user//home/$host/$remoteProjectRoot -force $localProjectRoot
}


# direnv
# pvp (python, virtualenv and packages) automates creation of direnv's `.envrc` file. call it with arguments for pyenv version and virtual
# environment name. e.g `ppv 3.10.0 foo`. It creates an `.envrc` file in the current directory. In addition to the snippets found in the 
# documentation for pyenv virtualenv, I've added a script to check if certain python modules are installed, and install them if they're not.
# This script is stored in ~/.config/my_custom_stuff
ppv() {
  # source ~/.config/my_custom_stuff/pip_install_if_required.sh
  FILE=.envrc
  # MODULES='"pynvim" "rope" "ropevim"'
  MODULES='"pynvim"'

  awk '{$1=$1};1' > $FILE <<EOM
    # -*- mode: sh; -*-
    # (rootdir)/.envrc : direnv configuration file
    # see https://direnv.net/
    # pyversion=\$(head .python-version)
    # pvenv=\$(head     .python-virtualenv)
    pyversion=$1
    pvenv=$2

    use python \${pyversion}
    # Create the virtualenv if not yet done
    layout virtualenv \${pyversion} \${pvenv}
    # activate it
    layout activate \${pvenv}

    # declare -a modules=($MODULES)
    # echo "checking modules: \${modules[*]}"
    # for i in "\${modules[@]}"
    # do
    #   pip_install_if_required \$i
    # done
EOM
  
}


export LC_ALL=en_US.utf-8 
export LANG="$LC_ALL"
export ZSH=$HOME/.oh-my-zsh

export SSH_KEY_PATH="~/.ssh/rsa_id"

export EDITOR=nvim
export VISUAL=$EDITOR

# export TERM="xterm-256color"
# export COLORTERM="truecolor"


# bat configuration file location
export BAT_CONFIG_PATH="$HOME/.bat.conf"


# Let compilers find zlib. Turn off for pyenv install.
export LDFLAGS="${LDFLAGS} -L/usr/local/opt/zlib/lib"
export CPPFLAGS="${CPPFLAGS} -I/usr/local/opt/zlib/include"


if [ "$(uname)" = "darwin" ]
then
  export FZF_BASE="~/.fzf/install"
elif [ "$(uname)" = "linux" ]
then 
  export FZF_BASE=" /home/linuxbrew/.linuxbrew/opt/fzf/install "
fi


if type rg &> /dev/null; then
  export FZF_DEFAULT_COMMAND='rg --files'
  export FZF_DEFAULT_OPTS='-m --height 50% --border'
fi


# Manpath
export MANPATH="/usr/local/man:$MANPATH"
export MANPATH="/usr/local/opt/coreutils/libexec/gnuman:$MANPATH"


# ====== PATH START =======================================================
# PATH is created in reverse order, so the first path in the path list was created last, and vice versa.
 

# PATH ambiguities in subshells (like when calling python from inside vim) are typically  caused by your shell config overriding
# the PATH previously set by the virtualenv. Either prevent them from doing so, or use this workaround:
# https://vi.stackexchange.com/questions/7644/use-vim-with-virtualenv/7654#7654
if [[ -n $VIRTUAL_ENV && -e "${VIRTUAL_ENV}/bin/activate" ]]; then
  source "${VIRTUAL_ENV}/bin/activate"
fi

if [ "$(uname)" = "Darwin" ]; then
  # add Google Cloud Platform CLI tools to PATH
  source '/usr/local/Caskroom/google-cloud-sdk/latest/google-cloud-sdk/path.zsh.inc'

  export PATH=$HOME/.cargo/bin:$PATH
  source "$HOME/.cargo/env"
fi

# pip will install things correctly
export PATH="/usr/local/opt/coreutils/libexec/gnubin:$PATH"
# export PATH="/usr/local/opt/python/libexec/bin:$PATH"
# bibtex executable
export PATH="/usr/local/texlive/texmf-local/:$PATH"
# `rabbitmq-server` installed using brew
export PATH=$PATH:/usr/local/opt/rabbitmq/sbin
# zprof
export PATH="/usr/local/opt/tcl-tk/bin:$PATH"
# go binaries
export PATH="$(go env GOPATH)/bin:$PATH"
# RVM - make sure this is the last PATH variable change.
export PATH="$PATH:$HOME/.rvm/bin"

export PATH=/usr/local/sbin:$PATH
export PATH=$HOME/bin:/usr/local/bin:$PATH:/usr/sbin

# if system is linux, add linuxbrew to path
if [ "$(uname)" = "Linux" ]; then
    export PATH="/home/linuxbrew/.linuxbrew/bin:/home/linuxbrew/.linuxbrew/sbin:$PATH"
fi
